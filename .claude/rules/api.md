---
paths:
 - "lib/api/**/*"
 - "test/api/**/*"
---

# How API Bindings Work in This Codebase

## Structure

The API layer lives in `lib/api/` with three main parts:

- **`core.dart`** — The `ApiConnection` class, which provides HTTP methods (`get`, `post`, `patch`, `delete`, `postFileFromStream`) and handles auth, user-agent, JSON decoding, and error handling.
- **`lib/api/route/`** — One file per API endpoint group (messages, channels, typing, etc.). These are the "bindings" — top-level functions that call `ApiConnection` methods.
- **`lib/api/model/`** — Data types used by the API (events, models, narrows, etc.), with JSON serialization via `json_annotation` + `build_runner`.

## Writing a Route Binding

Each route binding follows a consistent pattern:

1. **Top-level async function**, not a method on `ApiConnection`. First parameter is always `ApiConnection connection`, remaining are named parameters for the API endpoint's parameters:
   ```dart
   Future<CreateSavedSnippetResult> createSavedSnippet(ApiConnection connection, {
     required String title,
     required String content,
   }) {
   ```

   The function name exactly matches the slug in the API docs URL, converted to camel case.

2. **Doc comment** with a link to the Zulip API docs: `/// https://zulip.com/api/create-saved-snippet`

3. **Calls `connection.get`/`.post`/`.patch`/`.delete`** with:
   - A `routeName` string (camelCase function name, e.g. `'createSavedSnippet'`)
   - A `fromJson` constructor for the result type (or `(_) {}` for `void` returns)
   - The URL path (relative to `/api/v1/`)
   - A `Map<String, dynamic>?` of parameters

4. **Parameter encoding**: values are automatically JSON-encoded (via `encodeParameters()`) unless wrapped in `RawParameter(...)`, which passes the string through as-is. String parameters that shouldn't be double-quoted use `RawParameter`. Optional params are included conditionally with `if (x != null)`.

5. **Server version compat**: Use `connection.zulipFeatureLevel!` to check feature levels and adapt the request (e.g., different param names for old vs new servers). Mark these with `// TODO(server-N)` comments.

## Writing a Result Type

Result classes use `@JsonSerializable(fieldRename: FieldRename.snake)` and follow this template:

```dart
@JsonSerializable(fieldRename: FieldRename.snake)
class CreateSavedSnippetResult {
  final int savedSnippetId;

  CreateSavedSnippetResult({
    required this.savedSnippetId,   // all params required, even nullable ones
  });

  factory CreateSavedSnippetResult.fromJson(Map<String, dynamic> json) =>
    _$CreateSavedSnippetResultFromJson(json);

  Map<String, dynamic> toJson() => _$CreateSavedSnippetResultToJson(this);
}
```

The `.g.dart` file (generated by `build_runner`) is referenced via `part 'foo.g.dart';`. After editing, run `tools/check --fix build_runner` to regenerate.

## For Void-Returning Endpoints

When the response body isn't needed, pass `(_) {}` as the `fromJson` and return `Future<void>`:

```dart
Future<void> deleteMessage(ApiConnection connection, {
  required int messageId,
}) {
  return connection.delete('deleteMessage', (_) {}, 'messages/$messageId', {});
}
```

## Testing

Tests live in `test/api/route/` and use `FakeApiConnection`:

1. `connection.prepare(json: ...)` sets up a canned response
2. Call the binding function
3. `connection.takeRequests()` to inspect the sent request (method, URL path, body fields)
4. `check(result)` to verify the deserialized response

Check extensions for result types go in `route_checks.dart`.

## Reading API docs

- For the API changelog, never try to fetch https://zulip.com/api/changelog .
  Instead, read the source code of that page, at ../zulip/api_docs/changelog.md .
- The pages at api/register-queue and api/get-events are very long. For these,
  use curl to fetch the page and save the file, then find what you need in the
  saved file. Other API doc pages are not too long; don't bother saving those
  (the permissions prompts would be annoying).

## Key Conventions

- When documenting the API model (as in dartdoc), prefer referring to the API doc itself, with a URL, rather than writing down new definitions.
- In general, group class fields logically, following the approach of existing items.
- Where the same list of parameters or fields appears in multiple places, they should have the exact same order as each other.
- All constructor parameters in API types use `required`, even for nullable fields (see README "Require all parameters in API constructors")
- Minimum supported server is Zulip Server 7.0 (feature level 185)
- Use `TODO(server-N)` comments for version-gated code paths
- Generated files (`.g.dart`) must be kept up to date via `build_runner`
- When interpreting data from the server, prefer checking what's in the data rather than explicit version checks. For example, if a field isn't present that new servers always send, interpret the data accordingly (the server is too old to have that field) rather than checking the server version explicitly. Explicit version checks are very rarely needed on the response-handling side.
